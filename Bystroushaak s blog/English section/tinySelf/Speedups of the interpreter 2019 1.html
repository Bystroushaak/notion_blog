<html>
  <head>
    <title>Speedups of the interpreter 2019/1</title>
    <link rel="stylesheet" type="text/css" href="../../../style.css" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="alternate" type="application/atom+xml" href="http://rfox.eu/raw/feeds/notion_blog.xml" />
  </head>
  <body>
    <a href="../../index.html" class="breadcrumb">Bystroushaak&#x27;s blog</a> / <a href="../index.html" class="breadcrumb">English section</a> / <a href="index.html" class="breadcrumb">tinySelf</a> / Speedups of the interpreter 2019/1

    <article id="35fe6656-44f2-4f3d-9e90-77938e0f9259" class="page sans">
      <header>
        <h1 class="page-title">Speedups of the interpreter 2019/1</h1>
      </header>
      <div class="page-body">
        <p id="cd88bf70-0773-4cda-aafb-f3f2ad917681">
          <time>@2019/01/29</time>
        </p>
        <p id="381a2a80-9fdf-4217-bc1b-a8c13e5dc593">So, since I did some benchmarks (<a href="Simple while benchmark 2019 01 06.html">Simple while benchmark 2019.01.06</a>), I had high hopes for speedup using rpython&#x27;s JIT.</p>
        <p id="172d60a5-0dce-4920-bc02-d9d0c19c65b9">As it turned out, it didn&#x27;t work at all - it actually runs many times slower (62 seconds instead of 17).</p>
        <p id="cd0408ce-6388-48d5-b0fa-985779b4246b">Several attempts at tweaking the code revealed where was the problem - I had to specify almost everything as &quot;red&quot; variable. Even things like program counter, which I didn&#x27;t expect at all.</p>
        <p id="a84a9b94-a142-453d-82b1-ccb2cab33764">With those improvements, code run 20% faster than without JIT. Obviously, this wasn&#x27;t acceptable, so I had to investigate.</p>
        <h1 id="22b061f5-9184-494b-a0b8-ed46a2d9c3f3">Numeric ints</h1>
        <p id="d64c7797-c875-4044-ae48-243605449395">So far, I have been using boxed integer values represented as </p>
        <pre id="520b59d0-81f2-4b90-bf10-12ca07bcb94b" class="code"><code>def add(_, self, parameters):
    obj = parameters[0]
    # yeah, this can&#x27;t be factored out, I&#x27;ve tried..
    assert isinstance(self, PrimitiveIntObject)
    assert isinstance(obj, _NumberObject)

    return obj.result_type(self.value + obj.value)

# ... other primitive functions ...

class PrimitiveIntObject(_NumberObject):
    def __init__(self, value, obj_map=None):
        _NumberObject.__init__(self, obj_map)

        self.value = value

        add_primitive_fn(self, &quot;+&quot;, add, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;-&quot;, substract, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;*&quot;, multiply, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;/&quot;, divide, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;%&quot;, modulo, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;&lt;&quot;, lt, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;&lt;=&quot;, lte, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;&gt;&quot;, gt, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;&gt;=&quot;, gte, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;==&quot;, compare, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;asString&quot;, as_string, [])
        add_primitive_fn(self, &quot;asFloat&quot;, as_float, [])

    @property
    def float_value(self):
        return float(self.value)

    def result_type(self, val):
        return PrimitiveIntObject(val)

    def __eq__(self, obj):
        if not hasattr(obj, &quot;value&quot;):
            return False

        return self.value == obj.value

    def __str__(self):
        return str(int(self.value))</code>
</pre>
        <p id="6ecf7555-87fa-4834-8180-5fe62d0edcc3">This may look strange, but you have to understand that functionality is not used from the class and it&#x27;s surrounding code itself (=not from rpython), but from the inside of the tinySelf. <code>add_primitive_fn()</code> adds into slots of the insides of <code>PrimitiveIntObject</code> that is represented in tinySelf code objects which wrap given &quot;primitive&quot; code written in RPython.</p>
        <p id="76595431-c228-46f0-bb42-bc68ba93b22a">As you can see, every integer value is boxed inside of class, which is then bound to functions, which manipulate internal <code>.value</code> property. This is obviously highly ineffective.</p>
        <p id="0f051810-0419-4287-a8fb-46b3b308d1fb">RPython should translate this into C and that in turn should optimize the code, but is there better way how to tell RPython that &quot;this is int, so treat is as int&quot;?</p>
        <p id="94a6e098-18d8-49ed-a15a-da3a6be718da">I thought there is in <a href="https://rpython.readthedocs.io/en/latest/rlib.html#objectmodel">UnboxedValue</a>, but it turned out that I don&#x27;t really remember this from reading the documentation correctly. Ouch.</p>
        <p id="03c5f35e-2a3a-45b5-8209-6e284ee69b4b">At least I&#x27;ve added <code>_immutable_fields_ = [&quot;value&quot;]</code> declaration to all constant primitives, but it turned out that this didn&#x27;t improve the performance either. Ouch^2.</p>
        <h1 id="9d4b7871-9a00-41d4-aeac-b59ec5a5a2ed">Profiling logs</h1>
        <p id="0fec2019-91ca-40a3-95f9-3cb4b35c22c9">Instead of guessing, I&#x27;ve decided to profile the code. I&#x27;ve only profiled the code with profiler once before using <code>valgrind</code>, so I&#x27;ve just used google and found out <a href="http://www.pixelbeat.org/programming/profiling/">Linux Profiling tools and techniques</a>, which gave me two commands to run:</p>
        <pre id="7dbac1a9-e6a4-4932-a5e0-87b7f1f996d1" class="code"><code>valgrind --tool=callgrind ./tSelf tests/scripts/simple_while_benchmark.self</code>
</pre>
        <figure id="bb40f15d-1907-443b-95e0-234b37a1f084">
          <div class="source">
            <a href="Speedups of the interpreter 2019 1/callgrind.out.2530.txt">https://s3-us-west-2.amazonaws.com/secure.notion-static.com/57c100e6-92fb-4037-ab63-111301aee646/callgrind.out.2530.txt</a>
          </div>
        </figure>
        <p id="f02f86f9-d87a-4692-a6b2-b34facc63bec">and then</p>
        <pre id="ede5d25d-23a2-4d99-8d32-06dc224a88e3" class="code"><code>kcachegrind callgrind.out.*</code>
</pre>
        <p id="ed0c4f9d-353b-4baa-aa11-025c72bb1080">to visualize the code:</p>
        <figure id="673efe48-d19b-4297-9615-374f379d0cef" class="image">
          <a href="Speedups of the interpreter 2019 1/profiler_1.png">
            <img style="width:1920px" src="Speedups of the interpreter 2019 1/profiler_1.png" />
          </a>
        </figure>
        <figure id="cdd53cf8-f9ca-472b-bc8d-5a2419a7b1dc" class="image">
          <a href="Speedups of the interpreter 2019 1/profiler_2.png">
            <img style="width:1920px" src="Speedups of the interpreter 2019 1/profiler_2.png" />
          </a>
        </figure>
        <figure id="0a1c9401-7d8b-4753-9932-7ba7dc1da654" class="image">
          <a href="Speedups of the interpreter 2019 1/profiler_3.png">
            <img style="width:1920px" src="Speedups of the interpreter 2019 1/profiler_3.png" />
          </a>
        </figure>
        <p id="135dd53a-dc37-4d6e-88fb-d434365bd3ad">Few moments of clicking around clearly showed, that unholy lot of time was wasted by copying the <em>dicts</em> in the <code>add_primitive_fn</code>. I quickly realized, that each new int, float and string is created as new object and new map for this object.</p>
        <h1 id="e83a4fad-3fb4-43b9-885e-f1484ad5514b">New map for each int</h1>
        <p id="5536e7dd-1981-48c2-a87f-178d7d05ed68">As you may know, Self is prototype based language. That means it doesn&#x27;t use classes, which means that functionality is by default in each object. Code reuse is achieved using parent slots.</p>
        <p id="37a7eca9-7504-4792-9c37-083b6bf9f4ea">In class based languages, internal object representation holds just values and pointer to shared methods / description of the object&#x27;s structure in the <em>class</em>. Self uses similar trick by using <em>maps</em>. When object is created, it holds only data. With object is created its map, which holds metadata - information about slots, their names and so on.</p>
        <figure id="2445f3a8-e4c0-400d-989a-f531b22e4093" class="image">
          <a href="Speedups of the interpreter 2019 1/2019-01-2400.12.08.png">
            <img style="width:384px" src="Speedups of the interpreter 2019 1/2019-01-2400.12.08.png" />
          </a>
        </figure>
        <p id="733a7a82-ba29-49e0-aceb-db473c7d9b87">On the internal level, each time object is cloned, it shares its map with the original object, until some kind of structural change is made.</p>
        <figure id="4c68e4ee-a707-4264-a14c-884f99ad1d97" class="image">
          <a href="Speedups of the interpreter 2019 1/2019-01-2923.45.11.png">
            <img style="width:384px" src="Speedups of the interpreter 2019 1/2019-01-2923.45.11.png" />
          </a>
        </figure>
        <p id="5311680c-29e6-4f6d-ba0b-ab356cf21913">Quick look into the code confirmed that <em>ints</em>, <em>floats</em> and <em>strings</em> create maps again and again: </p>
        <pre id="be2fe417-3154-4c65-9d2a-f46acf66cba7" class="code"><code>class PrimitiveIntObject(_NumberObject):
    _immutable_fields_ = [&quot;value&quot;]
    def __init__(self, value, obj_map=None):
        _NumberObject.__init__(self, obj_map)

        ...</code>
</pre>
        <p id="d6acee57-d3db-48eb-961a-6f461627d2e8">As you can see, <code>_NumberObject</code>&#x27;s init is called with <code>obj_map</code> set to <code>None</code>, which creates new map. Constructor is called for each number, which in effect has a same effect, like there is a (dynamically created) class for each number. Ouch. And each string and float. Ouch ouch.</p>
        <p id="422d5551-ddfb-4fd5-a95f-3d5979ac1459">Fortunately, this is easy to fix. Just share the map between all ints (floats, strings). Quick fix and benchmark for ints proves, that this indeed speeds up the execution significantly; from ~18 seconds to 12 with unoptimized rpython translation without JIT.</p>
        <p id="9d98a8c6-dd08-4a08-8ef4-6e880a18db07">Additional optimizations on strings, and floats got down the execution time to something around 8 seconds.</p>
        <p id="4139de6a-3eea-4dc5-8d86-bf67118d5576">Constructor of the primitive int now looks like this:</p>
        <pre id="8b00616c-7755-403c-a38e-38d1621b6cc3" class="code"><code>class PrimitiveIntObject(_NumberObject):
    _OBJ_CACHE = ObjCache()
    _immutable_fields_ = [&quot;value&quot;]
    def __init__(self, value, obj_map=None):
        _NumberObject.__init__(self, PrimitiveIntObject._OBJ_CACHE.map)

        self.value = value

        if PrimitiveIntObject._OBJ_CACHE.map is not None:
            self.slots_references = PrimitiveIntObject._OBJ_CACHE.slots
            return

        add_primitive_fn(self, &quot;+&quot;, add, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;-&quot;, substract, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;*&quot;, multiply, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;/&quot;, divide, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;%&quot;, modulo, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;&lt;&quot;, lt, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;&lt;=&quot;, lte, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;&gt;&quot;, gt, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;&gt;=&quot;, gte, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;==&quot;, compare, [&quot;obj&quot;])
        add_primitive_fn(self, &quot;asString&quot;, as_string, [])
        add_primitive_fn(self, &quot;asFloat&quot;, as_float, [])

        if PrimitiveIntObject._OBJ_CACHE.map is None:
            PrimitiveIntObject._OBJ_CACHE.store(self)</code>
</pre>
        <p id="f7b62a79-3fed-4efc-b81e-79915da0bce9">All the magic is happening in the <code>_OBJ_CACHE</code>, which stores the <code>.map</code> and <code>.slots</code> properties, which are shared across all instances of <code>PrimitiveIntObject</code>. That makes sense, as only the <code>.value</code> is different for each instance.</p>
        <p id="0b11ae03-42bb-4dab-b7e3-9491cc5f7227">See the changes in <a href="https://github.com/Bystroushaak/tinySelf/commit/7946fdfecb339139f22947a0cefc871eccafdb1e">7946fdfecb339139f22947a0cefc871eccafdb1e</a>.</p>
        <h1 id="12590cc3-6cba-447c-81da-fbe39fccee7f">Don&#x27;t create new maps with each change</h1>
        <p id="7278a499-240a-49d4-9da6-90b6b2be1194">I usually work in pure python and don&#x27;t think much about the cost of the <em>creation</em> of the dictionary, as python is so slow, that it is nothing compared to cost of other operations. This benchmark of mine reminded me, that dictionaries are costly to create, so naturally, I asked <em>&quot;where else do I create dictionaries?&quot;</em></p>
        <p id="f2d8c35a-d4bd-4288-98cc-a8406764c1d4">And then I remembered - every time I change a structure of an object, I am currently creating the copy of the map.</p>
        <p id="b15d7104-e0f3-4a18-b51d-748e0fb05cd5">You see, when you have Object and his clone, and you add or remove or shift slots in one of them, they don&#x27;t anymore share same map, otherwise they both would be changed. I didn&#x27;t have any checks, so each operation like addition of the new slot created new map, even if the map wasn&#x27;t shared between multiple objects.</p>
        <p id="95e5dc5f-02e9-4794-adaf-287c248d6bd9">It turned out, that this also have massive impact on performance as it got simple while benchmark execution time down to 4.2 seconds. And only change it required is to add new method and bool property to check when doing structural changes:</p>
        <pre id="239d926c-329f-45a2-a6a2-bbd7d011442a" class="code"><code>def _clone_map_if_used_by_multiple_objects(self):
        if self.map.used_in_multiple_objects:
            self.map = self.map.clone()</code>
</pre>
        <p id="58af517a-c0b5-4037-99a1-3d16cdce05f5">as you can see in <a href="https://github.com/Bystroushaak/tinySelf/commit/f5f0efe4559742bf91973184893a01923fff4e3b">f5f0efe4559742bf91973184893a01923fff4e3b</a>.</p>
        <h1 id="7418f07a-3138-4166-84cc-38787f75054c">Clone block traits</h1>
        <p id="9b93e5f7-d1c4-4bc9-87cc-cb1a32d97822">Another low hanging fruit is block traits, which is an object, that is created and dynamically bound to each block literal moved on stack. Simply by caching this object, cloning it and change the replacement, I&#x27;ve got down another almost second down to 3.47 seconds.</p>
        <p id="84663859-6bab-4212-a9de-c42c78e8369c">Instead of</p>
        <pre id="6db855d7-750c-4b93-abc1-ed6d0a1a037b" class="code"><code>def add_block_trait(block):
    obj = Object()
    obj.meta_add_slot(&quot;value&quot;, block)
    obj.meta_add_slot(&quot;with:&quot;, block)
    obj.meta_add_slot(&quot;with:With:&quot;, block)
    obj.meta_add_slot(&quot;with:With:With:&quot;, block)
    obj.meta_add_slot(&quot;with:With:With:With:&quot;, block)
    obj.meta_add_slot(&quot;withAll:&quot;, block)
    add_primitive_fn(block, &quot;asString&quot;, _print_block_source, [])
    add_primitive_fn(block, &quot;getLineNumber&quot;, _get_lineno, [])

    obj.scope_parent = _BLOCK_TRAIT

return obj</code>
</pre>
        <p id="76180af9-4268-4fc1-8f42-3cf8c5e8af08">there is now cached version:</p>
        <pre id="5d3ce8de-30bc-42e6-b498-bd18cb3754c8" class="code"><code>def _create_block_trait_prototype():
    obj = Object()

    placer = PrimitiveNilObject()

    obj.meta_add_slot(&quot;value&quot;, placer, check_duplicates=True)
    obj.meta_add_slot(&quot;with:&quot;, placer, check_duplicates=True)
    obj.meta_add_slot(&quot;with:With:&quot;, placer, check_duplicates=True)
    obj.meta_add_slot(&quot;with:With:With:&quot;, placer, check_duplicates=True)
    obj.meta_add_slot(&quot;with:With:With:With:&quot;, placer, check_duplicates=True)
    obj.meta_add_slot(&quot;withAll:&quot;, placer, check_duplicates=True)

    obj.scope_parent = _USER_EDITABLE_BLOCK_TRAIT

    return obj


_BLOCK_TRAIT_PROTOTYPE = _create_block_trait_prototype()


def add_block_trait(block):
    obj = _BLOCK_TRAIT_PROTOTYPE.clone()
    obj.set_slot(&quot;value&quot;, block)

    add_primitive_fn(block, &quot;asString&quot;, _print_block_source, [])
    add_primitive_fn(block, &quot;getLineNumber&quot;, _get_lineno, [])

    return obj</code>
</pre>
        <p id="fbaf3cd3-18e4-4e98-a890-d8e9e0fef157">There is still need to clone the object, but objects now share same map and there is no dict-creation involved.</p>
        <p id="de1ef170-1a7a-431d-9260-bdda7b5a78fe">See the full change in <a href="https://github.com/Bystroushaak/tinySelf/commit/b41d8e9c2157e1571c3b3f0fcf401be540a35360">b41d8e9c2157e1571c3b3f0fcf401be540a35360</a>.</p>
        <h1 id="759c9e34-66ee-47aa-bd61-cad92f523394">Additional speedups</h1>
        <p id="27a65e13-9cfe-4c30-9719-58d6fea856fe">I find it really amazing how much few simple tricks and caches in the right place speed up the benchmark. From 16.26 seconds to 3.47. That&#x27;s more than 460%!</p>
        <p id="6ecbc9bc-40b3-40f1-9d15-c1bfa62a4c78">My goal is to get down under one second, ideally under or around 100 milliseconds with JIT.</p>
        <p id="269ecf1c-c460-499f-b7f1-ee10a87303dc">Next things on my todolist:</p>
        <ul id="2c207202-7e34-46cf-8b86-04530e68d4ba" class="to-do-list">
          <li>
            <div class="checkbox checkbox-off">
            </div>
            <span class="to-do-children-unchecked">Play with the process context switching after right amount of instructions.</span>
          </li>
        </ul>
        <ul id="dd2e2ffb-8b8e-406a-80c6-bae28a87f54d" class="to-do-list">
          <li>
            <div class="checkbox checkbox-off">
            </div>
            <span class="to-do-children-unchecked">Global lookup table, or maybe local <code>CodeContext</code> caches for string messages to allow translating them to numbers for speedup when looking up in dicts.</span>
          </li>
        </ul>
        <ul id="091dc525-0d5a-4b8f-a005-c5559bffe5c6" class="to-do-list">
          <li>
            <div class="checkbox checkbox-off">
            </div>
            <span class="to-do-children-unchecked"><code>@jit.elidable</code> for pure functions.</span>
          </li>
        </ul>
        <ul id="4097aafc-7f0a-4400-bed2-6d039e670445" class="to-do-list">
          <li>
            <div class="checkbox checkbox-off">
            </div>
            <span class="to-do-children-unchecked">Compilation of all slots into their indexes and elimination of the dict lookups until structural changes are made.</span>
          </li>
        </ul>
        <ul id="1895e02f-d813-409d-bc17-95b26ba66cf5" class="to-do-list">
          <li>
            <div class="checkbox checkbox-off">
            </div>
            <span class="to-do-children-unchecked">Cacheing of the parent lookups with quick check whether any of the parent structure was changed.</span>
          </li>
        </ul>
        <ul id="fe10e0f6-326e-47c8-9fc8-e74274fab1ee" class="to-do-list">
          <li>
            <div class="checkbox checkbox-off">
            </div>
            <span class="to-do-children-unchecked">Inspiration by <a href="https://github.com/hpi-swa/RSqueak">RSqueak</a> and <a href="https://github.com/SOM-st/RPySOM">RPySOM</a>.</span>
          </li>
        </ul>
        <p id="bf66e1b0-0719-451d-a89a-16aaadebb193">
        </p>
      </div>
    </article>
  </body>
</html>
