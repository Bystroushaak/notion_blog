<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Jak se píše programovací jazyk 4: Objektový layout</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css">
  <link rel="alternate" type="application/atom+xml" href="http://blog.rfox.eu/atom.xml">
  <link rel="shortcut icon" href="http://blog.rfox.eu/favicon.ico"><!-- Global site tag (gtag.js) - Google Analytics -->

  <script src="https://www.googletagmanager.com/gtag/js?id=UA-142545439-1">
  </script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'UA-142545439-1');
  </script>
  <style>
  .hll { background-color: #ffffcc }
  .c { color: #408080; font-style: italic } /* Comment */
  .err { border: 1px solid #FF0000 } /* Error */
  .k { color: #008000; font-weight: bold } /* Keyword */
  .o { color: #666666 } /* Operator */
  .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
  .cm { color: #408080; font-style: italic } /* Comment.Multiline */
  .cp { color: #BC7A00 } /* Comment.Preproc */
  .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
  .c1 { color: #408080; font-style: italic } /* Comment.Single */
  .cs { color: #408080; font-style: italic } /* Comment.Special */
  .gd { color: #A00000 } /* Generic.Deleted */
  .ge { font-style: italic } /* Generic.Emph */
  .gr { color: #FF0000 } /* Generic.Error */
  .gh { color: #000080; font-weight: bold } /* Generic.Heading */
  .gi { color: #00A000 } /* Generic.Inserted */
  .go { color: #888888 } /* Generic.Output */
  .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
  .gs { font-weight: bold } /* Generic.Strong */
  .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
  .gt { color: #0044DD } /* Generic.Traceback */
  .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
  .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
  .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
  .kp { color: #008000 } /* Keyword.Pseudo */
  .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
  .kt { color: #B00040 } /* Keyword.Type */
  .m { color: #666666 } /* Literal.Number */
  .s { color: #BA2121 } /* Literal.String */
  .na { color: #7D9029 } /* Name.Attribute */
  .nb { color: #008000 } /* Name.Builtin */
  .nc { color: #0000FF; font-weight: bold } /* Name.Class */
  .no { color: #880000 } /* Name.Constant */
  .nd { color: #AA22FF } /* Name.Decorator */
  .ni { color: #999999; font-weight: bold } /* Name.Entity */
  .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
  .nf { color: #0000FF } /* Name.Function */
  .nl { color: #A0A000 } /* Name.Label */
  .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
  .nt { color: #008000; font-weight: bold } /* Name.Tag */
  .nv { color: #19177C } /* Name.Variable */
  .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
  .w { color: #bbbbbb } /* Text.Whitespace */
  .mb { color: #666666 } /* Literal.Number.Bin */
  .mf { color: #666666 } /* Literal.Number.Float */
  .mh { color: #666666 } /* Literal.Number.Hex */
  .mi { color: #666666 } /* Literal.Number.Integer */
  .mo { color: #666666 } /* Literal.Number.Oct */
  .sa { color: #BA2121 } /* Literal.String.Affix */
  .sb { color: #BA2121 } /* Literal.String.Backtick */
  .sc { color: #BA2121 } /* Literal.String.Char */
  .dl { color: #BA2121 } /* Literal.String.Delimiter */
  .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
  .s2 { color: #BA2121 } /* Literal.String.Double */
  .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
  .sh { color: #BA2121 } /* Literal.String.Heredoc */
  .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
  .sx { color: #008000 } /* Literal.String.Other */
  .sr { color: #BB6688 } /* Literal.String.Regex */
  .s1 { color: #BA2121 } /* Literal.String.Single */
  .ss { color: #19177C } /* Literal.String.Symbol */
  .bp { color: #008000 } /* Name.Builtin.Pseudo */
  .fm { color: #0000FF } /* Name.Function.Magic */
  .vc { color: #19177C } /* Name.Variable.Class */
  .vg { color: #19177C } /* Name.Variable.Global */
  .vi { color: #19177C } /* Name.Variable.Instance */
  .vm { color: #19177C } /* Name.Variable.Magic */
  .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@Bystroushaak">
  <meta name="twitter:creator" content="@Bystroushaak">
  <meta name="twitter:title" content="Jak se píše programovací jazyk 4: Objektový layout">
  <meta name="twitter:description" content="Dalším logickým krokem by mělo být vytvoření virtuálního stroje, který bude programovací jazyk interpretovat, a kompilátoru, který pro tento virtuální stroj zkompiluje zdrojový kód. Před tím, než se do toho můžu pustit je však třeba ujasnit si, nejlépe formou konkrétní implementace, jak bude vypadat reprezentace a rozložení objektů v paměti.">
  <meta name="twitter:image" content="http://blog.rfox.eu/map_0.png">
  <script src="../../../scripts.js">
  </script>
</head>
<body onload="on_body_load();">
  <div id="sidebar_top">
    <h3>New posts:</h3>
    <ul>
      <li>
        <a href="../../../en/Weekly_updates/Lifelog_2020-05-25_Work_in_progress_everywhere.html">Lifelog 2020-05-25; Work in progress everywhere</a>
      </li>
      <li>
        <a href="http://blog.rfox.eu/en/Improvements/Vitamins_nootropics_and_other_boosters.html">Vitamins, nootropics and other boosters</a>
      </li>
      <li>
        <a href="http://blog.rfox.eu/en/objWiki/Transaction_support_for_simple_in_memory_database.html">Transaction support for simple in-memory database</a>
      </li>
      <li>
        <a href="http://blog.rfox.eu/en/Improvements.html">Improvements</a>
      </li>
      <li>
        <a href="http://blog.rfox.eu/en/Weekly_updates/Biweekly_update_2020_04_22_A_lot_of_programming.html">Biweekly update 2020-04-22; A lot of programming</a>
      </li>
    </ul>& <a href="../../../Changelog.html">more</a>
  </div><a class="breadcrumb" href="../../../index.html">Bystroushaak's blog</a> / <a class="breadcrumb" href="../../index.html">Czech section</a> / <a class="breadcrumb" href="../index.html">Jak se píše programovací jazyk</a> / Jak se píše programovací jazyk 4: Objektový layout
  <article id="6f84fd21-f69e-4275-9575-d0c20719bc2c" class="page sans">
    <header>
      <h1 class="page-title">Jak se píše programovací jazyk 4: Objektový layout</h1>
    </header>
    <div class="page-body">
      <p id="ff814f60-f037-4789-9846-3bb68ae5d7ce" class=""><time>@2019/03/13</time></p>
      <p id="3c97b191-83e4-49fb-a500-e28593b736d7" class="">Dalším logickým krokem by mělo být vytvoření virtuálního stroje, který bude programovací jazyk interpretovat, a kompilátoru, který pro tento virtuální stroj zkompiluje zdrojový kód. Před tím, než se do toho můžu pustit je však třeba ujasnit si, nejlépe formou konkrétní implementace, jak bude vypadat reprezentace a rozložení objektů v paměti.</p>
      <p id="69dedfef-c946-4724-9bb3-516e368f5a20" class="">Specificky následující věci;</p>
      <ol id="9155f3b2-42f6-4559-8cbc-f2f93fa5d27d" class="numbered-list" start="1">
        <li>Jak budou objekty reprezentovány.</li>
      </ol>
      <ol id="b97f8cf4-920f-4249-a8a8-cb47438729ef" class="numbered-list" start="2">
        <li>Kde a jak budou umístěny.</li>
      </ol>
      <ol id="3e16d8b4-2faa-4729-abfb-9427d888d47e" class="numbered-list" start="3">
        <li>Jak se s tím vším bude pracovat.</li>
      </ol>
      <h2 id="4b4efd67-d705-4425-a5bb-519ad6ae7738" class="">Selfové objekty</h2>
      <p id="ec0483e5-557d-4c16-9ab9-f2a2c1a5d30e" class="">Přestože tento seriál je určen především pro pokročilé čtenáře, od kterých očekávám alespoň základní obeznámení se Selfem, pro jistotu zde rekapituluji na prototypech založený objektový model Selfu.</p>
      <p id="1fa9ce87-436a-4db9-b7bd-21c580e5fd6c" class="">Objekty v Selfu se chovají jako asociativní pole, které na <em>konkrétním jménu</em> uchovávají buďto hodnotu, nebo odkaz na jiné objekty. Pár <em>jméno : hodnota</em> je nazýván slotem. Objekt je kolekcí takovýchto slotů.</p>
      <pre id="add733ae-d6d7-4ef8-bca4-530e966daaa7" class="code"><code>(| slot = 1. another = 2 |)</code></pre>
      <p id="db60b715-6fc2-4f5d-bd65-82dc99ee5367" class="">Tento objekt na jisté úrovni abstrakce odpovídá slovníku <code>{"slot": 1, "another": 2}</code>.</p>
      <p id="3e914551-dd37-48c1-b37b-fd153d3d82fd" class="">Klíče v asociativním poli jsou přeloženy na konkrétní výsledek aktem <em>poslání zprávy objektu</em>. Zprávy můžou být unární (jednoduchý string bez mezer), binární (operátory jako +-*/ a tak podobně), či <em>keyword</em> (složené z jednoho, či více klíčových slov následovaných dvojtečkou).</p>
      <pre id="c7112f8d-5842-429a-99b4-ba53d08a4ea3" class="code"><code>obj unaryMessage.
obj + anotherObj.
obj keyword: anotherObj Message: evenMoreObjs.</code></pre>
      <p id="50565fb8-f379-4d9e-bae0-150abd4c706f" class="">Analogie k pythonu by byla:</p>
      <pre id="b7f4e113-bbea-4c19-9aae-ecf44967316d" class="code"><code>obj.unaryMessage()
obj.+(anotherObj)
obj.keyword:Message:(anotherObj, evenMoreObjs)</code></pre>
      <p id="3237f48e-feee-4440-96d4-216564a85f90" class="">Rozdíly oproti klasickému asociativnímu poli jsou následující:</p>
      <ul id="908de3d7-f12b-4384-a532-86827b550770" class="bulleted-list">
        <li>Pokud je výsledkem přeložení zprávy na slot objekt <em>obsahující kód</em>, je spuštěn v kontextu volaného objektu a jsou mu předány patřičné parametry.</li>
      </ul>
      <ul id="3ab23c08-d31a-4a67-837a-f1888fedd8cb" class="bulleted-list">
        <li>Pokud není slot v objektu nalezen, objekt má možnost na to reagovat.</li>
      </ul>
      <ul id="bfe9c50b-9436-44ba-8389-b7709930ed1e" class="bulleted-list">
        <li>Pokud objekt definuje rodičovský slot, je hledání slotu při neúspěchu přeneseno do něj. Tím je řešena delegace ve stylu dědičnosti.</li>
      </ul>
      <p id="fe2a8bb2-8dcb-4283-8e49-f293a13c679d" class="">Objekt je možné interně reprezentovat třídou zhruba a velmi abstraktně následujícího typu:</p>
      <pre class="code"><code><span class="k">class</span> <span class="nc">Object</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slots</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scope_parent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primitive_code</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre>
      <p id="176507ec-31da-40ac-9db7-029b061d5c36" class="">Tedy <code>Objekt</code> může obsahovat sloty jako hashmapu, seznam přijímaných parametrů jako pole, slovník odkazů na rodiče a kód, což je zase jiný objekt, něco jako pole zpráv, které se postupně zasílají.</p>
      <p id="00fd8bd5-e66a-4d14-b5a5-ffe0231bc73d" class="">Od začátku jsem chtěl, aby sloty byly uloženy se zachováním pořadí v <code>OrderedDictu</code>, místo v klasické hashmapě. To není tak moc podstatné, pro samotný programovací jazyk, jako pro jeho využití k ukládání strukturovaných informací. Díky tomu je možné do stromové struktury například 1:1 konvertovat XML s poměrně malým <em>overheadem</em>.</p>
      <h2 id="a31d5c15-6c70-4d0f-b50b-06fcb0a2f1bf" class="">Reprezentace objektů</h2>
      <p id="1f44eda6-641d-48de-bbb1-539867442b28" class="">V na třídách založených jazycích jsou objekty reprezentovány přibližně nějak jako pointer na třídu následovaný polem s datovými sloty udržujícími členské proměnné. Ve třídě samotné je uložen popis toho, co se dělá s datovými sloty. Tím je šetřena paměť, neboť samotná funkcionalita objektu je v ní uložena jen jednou pro všechny instance.</p>
      <p id="11af0d6d-70f3-4a21-bdb8-df92e5f78096" class="">Self je na prototypech založený jazyk, kde nic jako třídy není. Objekty nejsou <em>instancovány</em>, ale <em>klonovány</em> z jiných objektů. Přesto, či respektive právě proto, je možné použít stejný trik, jako u jazyků s třídami. Při klonování je v paměti vytvořena takzvaná <em>mapa</em> a uživateli je vrácen objekt, který je podobně jako v předchozím případě pouze polem s hodnotami a pointerem na <em>mapu</em>. Pokud uživatel klon strukturálně modifikuje (přidá / ubere / přejmenuje sloty), je pro něj vytvořena samostatná mapa, do té doby jsou však mapy sdíleny.</p>
      <p id="b6f79370-efd7-45b9-a5f1-2a36dce8633d" class="">Rozložení v paměti se tedy mění následovně:</p>
      <pre class="code"><code><span class="k">class</span> <span class="nc">Object</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="nb">map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_parent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slot_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_slot_values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">Object</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span>
        <span class="n">o</span><span class="o">.</span><span class="n">scope_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_parent</span>
        <span class="n">o</span><span class="o">.</span><span class="n">_slot_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slot_values</span><span class="p">[:]</span>
        <span class="n">o</span><span class="o">.</span><span class="n">_parent_slot_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_slot_values</span><span class="p">[:]</span>

        <span class="k">return</span> <span class="n">o</span>


<span class="k">class</span> <span class="nc">Map</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_slotss</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">primitive_code</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre>
      <p id="21741387-2229-43ca-891e-98ed9e53116f" class="">V jakémsi pseudoUML to vypadá takto:</p>
      <figure id="88334089-2309-4ad4-a5fc-5014522c6dce" class="image">
        <a href="map_0.png"><img style="width:178px" src="map_0.png"></a>
      </figure>
      <p id="c1e71aef-4661-44fe-abee-2ee157656e6c" class="">Pokud dojde ke klonování objektu, je vytvořen nový objekt obsahující pole s odkazy na hodnoty. Všechny ostatní informace, jako rodičovské sloty, seznam parametrů a kód objektu jsou pro všechny klony uložené v jedné mapě, na kterou si předávají reference. Díky tomu je možné signifikantním způsobem šetřit paměť.</p>
      <figure id="acdd3d53-0803-4da6-a4d8-1dca2f7c4925" class="image">
        <a href="map_1.png"><img style="width:419px" src="map_1.png"></a>
      </figure>
      <p id="df090a8a-2d00-4d66-afe1-55bb871bdb6a" class="">To platí, i když se změní hodnota konkrétního slotu:</p>
      <figure id="e4db1c86-c57b-49d4-b149-5755b676d684" class="image">
        <a href="map_2.png"><img style="width:394px" src="map_2.png"></a>
      </figure>
      <p id="62a8fedc-8c30-4c6f-9cdb-570e26b7ec82" class="">Celá implementace se ovšem kapku zesložiťuje v případě kdy se změní struktura, neboť je potřeba patřičně ošetřit všechny manipulace objektu tak, aby došlo k vytvoření nové mapy.</p>
      <figure id="599fe379-e581-48a1-ae32-a2b6baf81822" class="image">
        <a href="map_3.png"><img style="width:417px" src="map_3.png"></a>
      </figure>
      <p id="1e7521bd-f5cc-469e-a940-76b0e6b5070d" class="">To jsem osobně vyřešil spoustou <code>meta_</code> metod. Například <code>.meta_add_slot()</code>, která do klonu přidá nový slot, před tím však vytvoří <em>klon mapy</em>, takže tento nový objekt již používá vlastní mapu, kterou si může upravovat jak chce.</p>
      <p id="3a2a399c-7f46-4faa-ba47-6fe770e63211" class="">Překlad názvu slotu probíhá následujícím způsobem:</p>
      <p id="5c34a614-1d8d-4e4e-93e1-4f91174338e7" class="">Je zavolána metoda <code>.get_slot()</code>, která se do <em>mapy</em> podívá, jestli obsahuje index patřičného slotu v <code>OrderedDictionary</code> property <code>._slots</code>. Pokud ano, vezme tento index a najde patřičnou hodnotu v poli <code>._slot_values</code>. Tu potom vrátí.</p>
      <p id="8bed57e4-77ca-41d7-a68f-35c82764fd05" class="">Uložení nové hodnoty probíhá podobně.</p>
      <h3 id="b176c208-7dac-4574-8f70-bf6b24bac446" class="">Meta operace</h3>
      <p id="85acb3ad-4334-43fd-985f-838aede0158d" class="">Meta-operacemi nazývám takové operace, které nějak mění strukturu objektu. Například přidání či odebrání nového slotu. Vzhledem k tomu že jsou sloty uloženy v <code>OrderedDict</code>u, je touto operací i prohození pozice slotu.</p>
      <h3 id="aa82b5b2-311c-4c7b-a5b4-2ab247cb12e9" class="">Kompozice</h3>
      <p id="849d0ac1-3597-40a4-9bc2-57beb4446ce2" class="">Vzhledem k tomu, že počet řádků narostl z původní několikařádkové myšlenky na pěkných pár stovek, rozhodl jsem se Objekt pro lepší čitelnost dekomponovat do několika tříd. Tato dekompozice nemá vliv na běh programu (stejně je z toho nakonec masivně <em>inlinované</em> C, které objekty nezná), je čistě jen pro lepší strukturovanost zdrojového kódu.</p>
      <p id="16286af8-76fe-4aed-80f2-e0b79521fcde" class="">Zde je UML výsledné podoby <em>objektového layoutu</em>:</p>
      <figure id="6626d9a6-07b9-489d-9d91-b7b0ad50646e" class="image">
        <a href="object_layout.png"><img style="width:887px" src="object_layout.png"></a>
      </figure>
      <p id="6674d19f-8870-4f29-9c75-bab35b56930f" class="">Zdrojový kód je možné najít v souboru:</p>
      <ul id="6dd913c3-bca7-40eb-b8ec-d7581c8f7de7" class="bulleted-list">
        <li>
          <a href="https://github.com/Bystroushaak/tinySelf/blob/master/src/tinySelf/vm/object_layout.py">object_layout.py</a>
        </li>
      </ul>
      <p id="e51947a8-c75a-47e0-88bf-deff0def1c1c" class="">Oproti tomu co jsem zatím popsal je možné vidět ještě mezi-třídu <code>_ObjectWithMapEncapsulation</code>, což je abstrakce nad většinou properties v mapě, abych nepřistupoval v kódu interpretru k interním záležitostem <em>mapy</em> přímo. Pro kód je mnohem výhodnější a čitelnější, když <em>mapa</em> zůstane čímsi na pozadí, optimalizací, která je pro vnější svět neviditelnou.</p>
      <h2 id="593c6350-b2f6-4ef8-994d-bba228725465" class="">Parent lookup</h2>
      <p id="1008a195-fa66-45ba-b2a5-ee832710b5b7" class="">Jednou z naprosto klíčových funkcionalit Selfu, která mu dodává mnoho elegance, jenž například postrádá javascript, je delegace na rodičovské sloty.</p>
      <p id="6b21acd2-b363-41d2-9633-b164ea41d126" class=""><code>Object</code> obsahuje kromě metody <code>.get_slot()</code>, jenž pouze hledá v <em>mapě</em> patřičný slot, také metody <code>.parent_lookup()</code> a <code>.slot_lookup()</code>. Druhá jmenovaná je tím, co se reálně používá všude v interpretru.</p>
      <p id="06397d75-eaf5-4a20-9efa-013a72b85c1a" class="">Metoda <code>.parent_lookup()</code> funguje následovně:</p>
      <p id="585de5ed-f8d5-4802-a5de-34bc38f64833" class="">Projde všechny rodičovské sloty a pokud mají <code>.visited</code> nastavené na <code>True</code>, tak je přeskočí. Pokud ne, podívá se do jejich <code>.slots</code> (respektive do jejich mapy..) a zkusí v nich najít jméno slotu. Pokud tam není, postupuje rekurzivně do hloubky pro rodičovské sloty prvního rodičovského slotu. Všechny objekty, které navštíví, si označí pomocít property <code>.visited</code> a uloží pro pozdější resetování této property. Pokud je slot nalezen v některém z rodičů, či jeho rodičů, je vrácen. Pokud není vůbec nalezen, je vráceno <code>None</code>. V obou případech jsou nakonec všechny prošlé objekty označeny jako <code>.visited = False</code>. Prvním rodičovským slotem, který je vždy prohledávám je speciální rodičovský slot <code>.scope_parent</code>, který je použit k uchovávání lokálních parametrů a kontextu lokálních a globálních proměnných.</p>
      <p id="f407e2c8-db30-490b-b29d-3d13ed0ae4ff" class="">Druhá jmenovaná metoda <code>.slot_lookup()</code> se prvně podívá do vlastního seznamu slotů pomocí <code>.get_slot()</code> a pokud tam nic nenajde, pokračuje metodou <code>.parent_lookup()</code>. Tím je implementovaná dědičnost.</p>
      <h1 id="f7036f96-f008-440b-af54-2b457c482db5" class="">Pokračování</h1>
      <p id="129c5c3a-fda8-42ed-b823-39752e2ee7cc" class="">Příště se podíváme na bajtkód a literály a v jaké je to celé uložené datové struktuře.</p>
      <h1 id="f5e79f19-5c60-4d03-a200-06785c1f0ae2" class="">Relevantní diskuze</h1>
      <ul id="b56a086b-0194-4c2e-9d11-726e78344e1a" class="bulleted-list">
        <li>
          <a href="http://www.abclinuxu.cz/blog/bystroushaak/2019/3/13/444907">Jak se píše programovací jazyk 4: Objektový layout</a> (abclinuxu)
        </li>
      </ul>
      <p id="24f67f22-0015-4fd5-b796-84ebccd22fd4" class=""></p>
    </div>
  </article>
  <div class="corner-ribbon top-right red">
    <a href="https://www.patreon.com/bePatron?u=2618881">Become a Patron</a>
  </div>
  <div id="sidebar_bottom">
    <h3>New posts:</h3>
    <ul>
      <li>
        <a href="../../../en/Weekly_updates/Lifelog_2020-05-25_Work_in_progress_everywhere.html">Lifelog 2020-05-25; Work in progress everywhere</a>
      </li>
      <li>
        <a href="http://blog.rfox.eu/en/Improvements/Vitamins_nootropics_and_other_boosters.html">Vitamins, nootropics and other boosters</a>
      </li>
      <li>
        <a href="http://blog.rfox.eu/en/objWiki/Transaction_support_for_simple_in_memory_database.html">Transaction support for simple in-memory database</a>
      </li>
      <li>
        <a href="http://blog.rfox.eu/en/Improvements.html">Improvements</a>
      </li>
      <li>
        <a href="http://blog.rfox.eu/en/Weekly_updates/Biweekly_update_2020_04_22_A_lot_of_programming.html">Biweekly update 2020-04-22; A lot of programming</a>
      </li>
    </ul>& <a href="../../../Changelog.html">more</a>
  </div>
</body>
</html>
